package plugin

import (
	"strings"

	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
)

type client struct {
	path string
	fd   protoreflect.FileDescriptor
	f    *File
}

func (g client) Need() bool {
	ss := g.fd.Services()
	for i := 0; i < ss.Len(); i++ {
		if g.hasHttpRuleOption(ss.Get(i)) {
			return true
		}
	}
	return false
}

func (g client) Generate() {
	g.f.P("// Code generated by protoc-gen-kratos-dart-http. DO NOT EDIT.")
	g.f.P()
	g.f.P(`import 'dart:convert';`)
	g.f.P(`import 'package:kratos_plugin/kratos_plugin.dart';`)
	g.f.P(`import 'package:http/http.dart' as http;`)
	if g.fd.Messages().Len() > 0 {
		g.f.P(`import '`, fileName(g.path), `.dart';`)
	}
	if g.fd.Enums().Len() > 0 {
		g.f.P(`import '`, fileName(g.path), `.enum.dart';`)
	}
	g.f.P()

	var n int
	ss := g.fd.Services()
	for i := 0; i < ss.Len(); i++ {
		if n > 0 {
			g.f.P()
		}
		if s := ss.Get(i); g.hasHttpRuleOption(s) {
			g.client(s)
			n++
		}
	}
}

func (g client) hasHttpRuleOption(s protoreflect.ServiceDescriptor) bool {
	ms := s.Methods()
	for j := 0; j < ms.Len(); j++ {
		// has rule and not custom
		rule, ok := g.rule(ms.Get(j))
		if !ok {
			continue
		}
		if _, ok := rule.Pattern.(*annotations.HttpRule_Custom); !ok {
			return true
		}
	}
	return false
}

func (g client) rule(m protoreflect.MethodDescriptor) (*annotations.HttpRule, bool) {
	r, ok := proto.GetExtension(m.Options(), annotations.E_Http).(*annotations.HttpRule)
	return r, ok
}

func (g client) client(s protoreflect.ServiceDescriptor) {
	if loc := g.fd.SourceLocations().ByDescriptor(s); loc.LeadingComments != "" {
		g.f.P(`/// `, strings.TrimSpace(loc.LeadingComments))
	}
	g.f.P(`abstract class `, s.Name(), `Client {`)

	ms := s.Methods()
	rules := make([]*annotations.HttpRule, 0, ms.Len())
	methods := make([]protoreflect.MethodDescriptor, 0, ms.Len())

	for i := 0; i < ms.Len(); i++ {
		m := ms.Get(i)
		rule, ok := g.rule(m)
		if ok {
			rules = append(rules, rule)
			methods = append(methods, m)
		}
	}

	for i, m := range methods {
		if i > 0 {
			g.f.P()
		}
		g.abstractMethod(m)
	}

	g.f.P(`}`)
	g.f.P()

	g.f.P(`class `, s.Name(), `ClientImpl implements `, s.Name(), `Client {`)
	g.f.P(`  final http.Client _client;`)
	g.f.P()
	g.f.P(`  const `, s.Name(), `ClientImpl(this._client);`)
	g.f.P()

	for i, m := range methods {
		if i > 0 {
			g.f.P()
		}
		g.method(m, rules[i])
	}
	g.f.P("}")
}

func (g client) abstractMethod(m protoreflect.MethodDescriptor) {
	loc := g.fd.SourceLocations().ByDescriptor(m)
	if loc.LeadingComments != "" {
		g.f.P(`  /// `, strings.TrimSpace(loc.LeadingComments))
	}

	g.f.P(`  Future<`, m.Output().Name(), `> `, firstCharLower(string(m.Name())), `(`, m.Input().Name(), ` request);`)
}

func (g client) method(m protoreflect.MethodDescriptor, rule *annotations.HttpRule) {
	loc := g.fd.SourceLocations().ByDescriptor(m)
	if loc.LeadingComments != "" {
		g.f.P(`  /// `, strings.TrimSpace(loc.LeadingComments))
	}

	kind, path := fromRule(rule)

	g.f.P(`  @override`)
	g.f.P(`  Future<`, m.Output().Name(), `> `, firstCharLower(string(m.Name())), `(`, m.Input().Name(), ` req) async {`)
	g.f.P(`    final arg = RequestArg.fromPattern(`)
	g.f.P(`      const HttpRule(`)
	g.f.P(`        kind: "`, kind, `",`)
	g.f.P(`        path: "`, path, `",`)
	g.f.P(`        body: "`, rule.Body, `",`)
	g.f.P(`      ),`)
	g.f.P(`      req.toJson(),`)
	g.f.P(`    );`)
	g.f.P()

	if kind == "get" {
		g.f.P(`    final resp = await _client.get(arg.url, headers: {`)
		g.f.P(`      'Content-Type': 'application/json',`)
		g.f.P(`    });`)
	} else {
		g.f.P(`    final resp = await _client.`, kind, `(`)
		g.f.P(`      arg.url,`)
		g.f.P(`      headers: {'Content-Type': 'application/json'},`)
		g.f.P(`      body: arg.body,`)
		g.f.P(`    );`)
	}
	g.f.P()

	g.f.P(`    if (resp.statusCode >= 200 && resp.statusCode <= 299) {`)
	g.f.P(`      return HelloReply.fromJson(jsonDecode(resp.body));`)
	g.f.P(`    }`)
	g.f.P(`    throw KratosError.fromJson(jsonDecode(resp.body));`)
	g.f.P(`  }`)
}

func fromRule(rule *annotations.HttpRule) (kind, path string) {
	switch p := rule.Pattern.(type) {
	case *annotations.HttpRule_Get:
		return "get", p.Get
	case *annotations.HttpRule_Put:
		return "put", p.Put
	case *annotations.HttpRule_Post:
		return "post", p.Post
	case *annotations.HttpRule_Delete:
		return "delete", p.Delete
	case *annotations.HttpRule_Patch:
		return "patch", p.Patch
	default:
		panic("unknown http rule pattern")
	}
}
